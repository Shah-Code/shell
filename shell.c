/**
 * shell
 * CS 341 - Fall 2023
*/

#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>
#include <stdio.h>
#include <signal.h>
#include "format.h"
#include "time.h"
#include "shell.h"
#include "sstring.h"
#include "string.h"
#include "vector.h"
#include "ctype.h"
#include <fcntl.h>

typedef struct process {
    char *command;
    pid_t pid;
} process;

void sighandle(int sig) {
	if (sig == SIGINT) {
		return;
	}
}

void piDESTROYER(process_info * p) {
	free(p->command);
	free(p->start_str);
	free(p->time_str);
	free(p);
}

process_info * piBUILDER(process * p) {
	process_info * pi = malloc(sizeof(process_info));
	pi->pid = p->pid;
	
	char filepath[100000];
	sprintf(filepath, "/proc/%d/stat", pi->pid);
	FILE * pstats = fopen(filepath, "r");

	
	char state = 'a';
	int nlwp = 0;
	unsigned long vsize = 0;
	unsigned long utime = 0;
	unsigned long stime = 0;
	unsigned long start_time = 0;
	char stat_data[102400];
	if (fgets(stat_data, sizeof(stat_data), pstats)) {
		sscanf(stat_data,"%*d %*s %c %*d %*d %*d %*d %*d %*u %*u %*u %*u %*u %lu %lu %*u %*u %*u %*d %d %*d %lu %lu", &state, &utime, &stime, &nlwp, &start_time, &vsize);	
        }
				
	fclose(pstats);
	
	pi->state = state;
	pi->nthreads = nlwp;
	pi->vsize = vsize / 1024;

	
	// code that was generated by an AI to get the btime
	FILE* btime_file = fopen("/proc/stat", "r");
  	unsigned long btime;
	char line[128];
  	while(fgets(line, 128, btime_file)) {
    		if(strncmp(line, "btime", 5) == 0) {
      			break;
		}
  	}
  	sscanf(line, "btime %lu", &btime);

  	fclose(btime_file);
	
	//turning start_time and total_time into strings
	time_t process_start = btime + (start_time / sysconf(_SC_CLK_TCK));
  	unsigned long total_time = (utime + stime) / sysconf(_SC_CLK_TCK);
	
	char time_str[1000];
	execution_time_to_string(time_str, 1000, total_time/60, total_time % 60);
	pi->time_str = malloc(strlen(time_str) + 1);
	strcpy(pi->time_str, time_str);
	
	char st_time[1000];
	struct tm * s_time_info = localtime(&process_start);
	time_struct_to_string(st_time, 1000, s_time_info);
	pi->start_str = malloc(strlen(st_time) + 1);
	strcpy(pi->start_str, st_time);

	pi->command = malloc(strlen(p->command) + 1);
	strcpy(pi->command, p->command);

	return pi;
}

int ext(vector * args, vector * plist) {
	// flush buffer first so stuff isn't whack
	
	fflush(stdout);
	int redFlag = 0;
	size_t size = vector_size(args);
	sstring * cmd = cstr_to_sstring("");
	sstring * space = cstr_to_sstring(" ");
	//size_t cmdlen = 0;
	char * cargs[size + 1];
	size_t i = 0;
	char * output = ">";
	char * append = ">>";
	char * input = "<";
	for (i = 0; i < size; i++) {
		char * a = vector_get(args, i);
		if (strcmp(a, output) == 0) {
			redFlag = 1;
			cargs[i] = NULL;
			break;
		} else if (strcmp(a, append) == 0) {
			redFlag = 2;
			cargs[i] = NULL;
			break;
		} else if (strcmp(a, input) == 0) {
			redFlag = 3;
			cargs[i] = NULL;
			break;
		} else {
			sstring * temp = cstr_to_sstring(vector_get(args, i));
			sstring_append(cmd, temp);
			sstring_destroy(temp);
			sstring_append(cmd, space);
			//cmdlen += (sizeof(vector_get(args, i)) / sizeof(char));
			cargs[i] = vector_get(args, i);
		}
	}

	// now change fd

	char * ccmd = sstring_to_cstr(cmd);
        
	sstring_destroy(cmd);
	sstring_destroy(space);

	cargs[size] = NULL;
	if (strcmp(vector_get(args, size - 1), "&") == 0) {
		cargs[size - 1] = NULL;
	}
	
	pid_t proc = fork();
	int stat;
	// same as all other fork exec wait stuff
	if (proc == -1) {
		print_fork_failed();
		free(ccmd);
		exit(1);
	}

	if (proc == 0) {
		print_command_executed(getpid());
		if (redFlag == 1) {
			int fd = open(vector_get(args, vector_size(args)-1), O_WRONLY | O_TRUNC, 0644);
			if (fd == -1) {
				print_redirection_file_error();
				exit(1);
			}
			dup2(fd, STDOUT_FILENO);
			execvp(vector_get(args, 0), cargs);
			close(fd);
		} else if (redFlag == 2) {
			int fd = open(vector_get(args, vector_size(args)-1), O_WRONLY | O_APPEND | O_CREAT, 0644);
			dup2(fd, STDOUT_FILENO);
			execvp(vector_get(args, 0), cargs);
			close(fd);
		} else if (redFlag == 3) {
			// code to read contents of file genearted by an AI
			FILE* fp = fopen(vector_get(args, vector_size(args)-1), "r");
			fseek(fp, 0, SEEK_END); 
			long fsize = ftell(fp);
			char *buffer = malloc(fsize + 1);
			fseek(fp, 0, SEEK_SET);
			fread(buffer, fsize, 1, fp);
			buffer[fsize] = '\0';
			fclose(fp);
			
			//take string and make it in form for execvp	
			sstring * argstring = cstr_to_sstring(buffer);
			free(buffer);
			vector * argsfile = sstring_split(argstring, ' ');
			sstring_destroy(argstring);
			char * cargofile[vector_size(argsfile) + 2];
			size_t f = 0;
			cargofile[0] = vector_get(args, 0);
			for (f = 1; f < (vector_size(argsfile) + 1); f++) {
				cargofile[f] = vector_get(argsfile, f-1);
			}
			cargofile[vector_size(argsfile) + 1] = NULL;
			execvp(vector_get(args, 0), cargofile);
			vector_destroy(argsfile);
		} else {
			execvp(vector_get(args, 0), cargs);

		}
		print_exec_failed(vector_get(args, 0));
		free(ccmd);
		exit(1);
	}

	if (proc > 0) {
		
		process * p = malloc(sizeof(process));
		p->pid = proc;
		p->command = malloc(strlen(ccmd) + 1);
		strcpy(p->command, ccmd);
		vector_push_back(plist, p);
		free(ccmd);
		if (strcmp(vector_get(args, vector_size(args) - 1), "&") != 0) {
			waitpid(proc, &stat, 0);
			if (WIFEXITED(stat)) {
				if (WEXITSTATUS(stat)) {
					return 0;
				}
			}
		}
	}
        	
	return 1;
}		

int substring(char * sub, vector * hist, size_t sidx, int vidx) {
	if (vidx == -1) {
		return vidx;
	}
	if (sub[sidx] == '\0') {
		return vidx;
	}
	if (sub[sidx] == ((char *) vector_get(hist, vidx))[sidx]) {
		return substring(sub, hist, sidx+1, vidx);
	}

	return substring(sub, hist, 0, vidx-1);
}


int shell(int argc, char *argv[]) {
    // TODO: This is the entry point for your shell.
    signal(SIGINT, sighandle);   
    // There are two cases wither1 arg start promtpt or hist/file or both
    if (argc == 2 || argc == 4 || argc >= 6) {
	    print_usage();
    }
    
    vector * process_list = shallow_vector_create();
    char * histname = NULL;
    char * scriptname = NULL;
    
    if (argc != 1) {
    	int option = 0;
    	while ((option = getopt(argc, argv, "h:f:")) != -1) {
        	if (option == 'f') {
			scriptname = optarg;
		} else if (option == 'h') {
			histname = optarg;
		} else {
			print_usage();
		}
	}
    }
    
    //handle hist / file or both
    
    vector * history = string_vector_create();
    char * hist_path = NULL;
    FILE * hist_file = NULL;

    if (histname != NULL) {
	    hist_path = get_full_path(histname);
            hist_file = fopen(hist_path, "r");
	    if (hist_file == NULL) {
		    print_history_file_error();
	    } else {
		    char * line = NULL;
		    size_t len = 0;
		    ssize_t bytes = 0;
		    while ((bytes = getline(&line, &len, hist_file)) != 1) {
			    if (bytes != 0) {
				 line[bytes - 1] = '\0';
			    }
		            vector_push_back(history, line);
		    }
		    free(line);
		    fclose(hist_file);
	    }
    }
    //script
    FILE * scriptfile = NULL;
    
    if (scriptname != NULL) {
	    scriptfile = fopen(scriptname, "r");
	    if (scriptfile == 0) {
		    print_script_file_error();
		    exit(1);
	    }
    }

    // shell prompt
    char * line = NULL;
    size_t len = 0;
    ssize_t bytes = 0;

    int done = 0;
    
    char * directory;
 
    do {
	int stat;
	size_t pi = 0;
	size_t pllen = vector_size(process_list);
	for (pi = 0; pi < pllen; pi++) {
		pid_t prid = ((process *) vector_get(process_list, pi))->pid;
			while (waitpid(prid, &stat, WNOHANG) > 0) {
				free(((process *)vector_get(process_list, pi))->command);
                        	free(((process *)vector_get(process_list, pi)));
				vector_erase(process_list, pi);
				pi = pi - 1;
				pllen = pllen - 1;
			}
	}
    	directory = get_full_path("./");
	print_prompt(directory, getpid());
	if (scriptname == NULL) {
		bytes = getline(&line, &len, stdin);
	} else {
		bytes = getline(&line, &len, scriptfile);
	}
	if (bytes == -1) {
		break;
	}
	if ((bytes > 0) && (line[bytes-1] == '\n')) {
		line[bytes-1] = '\0';
	}

	// command that won't be logic'd

	if (strcmp(line, "exit") == 0 || feof(stdin)) {
                done = 1;
	} else if (strcmp(line, "!history") == 0) {
		size_t i;
		for (i = 0; i < vector_size(history); i++) {
		       print_history_line(i, vector_get(history, i));
		}
	} else if (strcmp(line, "ps") == 0) {
		vector_push_back(history, line);
		print_process_info_header();
		size_t i;
		
		for (i = 0; i < vector_size(process_list); i++) {
			process_info * pi = piBUILDER(((process *)vector_get(process_list, i)));
			print_process_info(pi);
			piDESTROYER(pi);
		}

		process * shelp = malloc(sizeof(process));
                shelp->pid = getpid();
                shelp->command = malloc(8);
                strcpy(shelp->command, "./shell");
		process_info * pishell = piBUILDER(shelp);
		print_process_info(pishell);
                piDESTROYER(pishell);
		free(shelp->command);
		free(shelp);

 	} else if (strncmp(line, "stop", 4) == 0) {
		size_t i;
		size_t pfound = 0;
		pid_t passedpid;
		sscanf(line+4, "%u", &passedpid);
		for (i = 0; i < vector_size(process_list); i++) {
			process * p = ((process *) vector_get(process_list, i));
			if (passedpid == p->pid) {
				kill(passedpid, SIGSTOP);
				print_stopped_process(passedpid, p->command);
				pfound = 1;
			}
		}
		if (pfound == 0) {
			print_no_process_found(passedpid);
		}
	} else if (strncmp(line, "cont", 4) == 0) {
		size_t i;
                size_t pfound = 0;
                pid_t passedpid;
                sscanf(line+4, "%u", &passedpid);
                for (i = 0; i < vector_size(process_list); i++) {
                        process * p = ((process *) vector_get(process_list, i));
                        if (passedpid == p->pid) {
                                kill(passedpid, SIGCONT);
                                print_continued_process(passedpid, p->command);
                                pfound = 1;
                        }
                }
                if (pfound == 0) {
                        print_no_process_found(passedpid);
                }

	} else if (line[0] == '#') {
		if (strlen(line) > 1) {
			int  num;
			num = atoi(line+1);
			if (num < 0) {
				print_invalid_index();
			} else {
				if (num < (int) vector_size(history)) {
					char * ncmd = vector_get(history, num);
					sstring * sncmd = cstr_to_sstring(ncmd);
					vector * args = sstring_split(sncmd, ' ');
					sstring_destroy(sncmd);
					print_command(ncmd);
					ext(args, process_list);
					vector_destroy(args);
					vector_push_back(history, ncmd);
				} else {
					print_invalid_index();
				}
			}

		} else {
			print_invalid_index();
		}
	} else if (line[0] == '!') {
		int idx = substring((line + 1), history, 0, (vector_size(history) - 1));
		if (idx != -1) {
			sstring * scmd = cstr_to_sstring(vector_get(history, idx));
			vector * args = sstring_split(scmd, ' ');
			sstring_destroy(scmd);
			print_command(vector_get(history, idx));
			ext(args, process_list);
			vector_destroy(args);
			vector_push_back(history, vector_get(history, idx));
		} else {
			print_no_history_match();
		}

        } else {
		//these commands have arguments delineated by spaces we need to parse so converting to sstring makes it easier
		sstring * sline = cstr_to_sstring(line);
		vector * args = sstring_split(sline, ' ');
		// commands that can be logic'd
		vector_push_back(history, line);
		if (strcmp(vector_get(args, 0), "cd") == 0) {
			if (chdir(vector_get(args, 1)) == -1) {
				print_no_directory(vector_get(args, 1));
			}
		} else {
			int logicflag = -1;
			vector * argsUNO = string_vector_create();
			vector * argsDOS = string_vector_create();
			size_t i = 0;
			for (i = 0; i < vector_size(args); i++) {
				char * temp = vector_get(args, i);
				if (strcmp(temp, "&&") == 0) {
					size_t j = 0;
					for (j = 0; j < i; j++) {
						vector_push_back(argsUNO, vector_get(args, j));
					}
					for (j = i + 1; j < vector_size(args); j++) {
						vector_push_back(argsDOS, vector_get(args, j));
					}
					logicflag = 0;
				} else if (strcmp(temp, "||") == 0) {
					size_t j = 0;
                                        for (j = 0; j < i; j++) {
                                                vector_push_back(argsUNO, vector_get(args, j));
                                        }
                                        for (j = i + 1; j < vector_size(args); j++) {
                                                vector_push_back(argsDOS, vector_get(args, j));
                                        }

					logicflag = 1;
				} else if (temp[strlen(temp) - 1] == ';') {
					temp[strlen(temp) - 1] = '\n';
					size_t j = 0;
                                        for (j = 0; j <= i; j++) {
                                                vector_push_back(argsUNO, vector_get(args, j));
                                        }
                                        for (j = i + 1; j < vector_size(args); j++) {
                                                vector_push_back(argsDOS, vector_get(args, j));
                                        }

                                        logicflag = 2;
				}
			}	
			if (logicflag != -1) {
				if (logicflag == 0) {
					int a = ext(argsUNO, process_list);
					if (a == 1) {
						ext(argsDOS, process_list);
					}
				}
				if (logicflag == 1) {
					int a = ext(argsUNO, process_list);
					if (a != 1) {
						ext(argsDOS, process_list);
					}
				}
				if (logicflag == 2) {
					ext(argsUNO, process_list);
					ext(argsDOS, process_list);
				}
			} else {
				ext(args, process_list);
			}
			vector_destroy(argsUNO);
			vector_destroy(argsDOS);
		}
		vector_destroy(args);
		sstring_destroy(sline);	
       	} 
	free(directory);
    } while (done != 1);
     
    free(line);

    if (scriptname) {
	    fclose(scriptfile);
    }

    if (histname) {
	    FILE * to_write = fopen(hist_path, "w");
	    size_t i = 0;
	    for (i = 0; i < vector_size(history); i++) {
		    fprintf(to_write, "%s\n",(char *) vector_get(history, i));
	    }
	    fclose(to_write);
    }
    free(hist_path);
    vector_destroy(history);
    size_t pllen = vector_size(process_list);
    size_t pi = 0;
    for (pi = 0; pi < pllen; pi++) {
                        free(((process *)vector_get(process_list, pi))->command);
                        free(((process *)vector_get(process_list, pi)));
    }

    vector_destroy(process_list);
    return 0;
}
